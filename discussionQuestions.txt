1. A pro of using event driven programming is that we are able to make our code scalable and more modular. Because all of the events were split, I was able to make components once, and use it in other components making it easier to manage two seperate components (Flooding \ Neighbor Discovery). A con of using event driven programming is that all variables must be statically allocated and there is no central point to debug all your code.
2. In order to stop our packets from circulating indefinetely, we use a list to check if this message has arrived at the node before. The benefit from this is that we were able to drop packets that didn't even need to go through the TTL to figure out it is repeated minimizing the load on our network. If we only had the flooding check, we would have to wait for a packet to reach every node in our network or reach it's destination as a repeated packet. If we only had TTL we would have to wait for packets to simply expire which would be pretty close to reaching all other nodes.
3. In the best case situation in flooding all nodes should typically only send out one packet until it reaches the destination. In the worse case situation we would have all nodes see the same packet N times where N is the number of neighbors.
4. A better way to deal with multi hop communication is to only send it to all  neighboars other than the source you just received the packet from. This will get us ideal flooding like in the presentation given.
5. A design decision I would have changed from the skeleton code is that I would have malloc and other dynamic memory available. This would help us to create structures and write in memory more comfortably but would require the mote to have much more preinstalled memory.